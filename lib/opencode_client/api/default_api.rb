=begin
#opencode

#opencode api

The version of the OpenAPI document: 1.0.0

Generated by: https://openapi-generator.tech
Generator version: 7.18.0

=end

require 'cgi'

module OpencodeClient
  class DefaultApi
    attr_accessor :api_client

    def initialize(api_client = ApiClient.default)
      @api_client = api_client
    end
    # List agents
    # Get a list of all available AI agents in the OpenCode system.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @return [Array<Agent>]
    def app_agents(opts = {})
      data, _status_code, _headers = app_agents_with_http_info(opts)
      data
    end

    # List agents
    # Get a list of all available AI agents in the OpenCode system.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @return [Array<(Array<Agent>, Integer, Hash)>] Array<Agent> data, response status code and response headers
    def app_agents_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.app_agents ...'
      end
      # resource path
      local_var_path = '/agent'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'directory'] = opts[:'directory'] if !opts[:'directory'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Array<Agent>'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.app_agents",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#app_agents\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Write log
    # Write a log entry to the server logs with specified level and metadata.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @option opts [AppLogRequest] :app_log_request 
    # @return [Boolean]
    def app_log(opts = {})
      data, _status_code, _headers = app_log_with_http_info(opts)
      data
    end

    # Write log
    # Write a log entry to the server logs with specified level and metadata.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @option opts [AppLogRequest] :app_log_request 
    # @return [Array<(Boolean, Integer, Hash)>] Boolean data, response status code and response headers
    def app_log_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.app_log ...'
      end
      # resource path
      local_var_path = '/log'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'directory'] = opts[:'directory'] if !opts[:'directory'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:'app_log_request'])

      # return_type
      return_type = opts[:debug_return_type] || 'Boolean'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.app_log",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#app_log\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Set auth credentials
    # Set authentication credentials
    # @param provider_id [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @option opts [Auth] :auth 
    # @return [Boolean]
    def auth_set(provider_id, opts = {})
      data, _status_code, _headers = auth_set_with_http_info(provider_id, opts)
      data
    end

    # Set auth credentials
    # Set authentication credentials
    # @param provider_id [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @option opts [Auth] :auth 
    # @return [Array<(Boolean, Integer, Hash)>] Boolean data, response status code and response headers
    def auth_set_with_http_info(provider_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.auth_set ...'
      end
      # verify the required parameter 'provider_id' is set
      if @api_client.config.client_side_validation && provider_id.nil?
        fail ArgumentError, "Missing the required parameter 'provider_id' when calling DefaultApi.auth_set"
      end
      # resource path
      local_var_path = '/auth/{providerID}'.sub('{' + 'providerID' + '}', CGI.escape(provider_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'directory'] = opts[:'directory'] if !opts[:'directory'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:'auth'])

      # return_type
      return_type = opts[:debug_return_type] || 'Boolean'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.auth_set",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PUT, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#auth_set\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # List commands
    # Get a list of all available commands in the OpenCode system.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @return [Array<Command>]
    def command_list(opts = {})
      data, _status_code, _headers = command_list_with_http_info(opts)
      data
    end

    # List commands
    # Get a list of all available commands in the OpenCode system.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @return [Array<(Array<Command>, Integer, Hash)>] Array<Command> data, response status code and response headers
    def command_list_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.command_list ...'
      end
      # resource path
      local_var_path = '/command'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'directory'] = opts[:'directory'] if !opts[:'directory'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Array<Command>'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.command_list",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#command_list\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get configuration
    # Retrieve the current OpenCode configuration settings and preferences.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @return [Config]
    def config_get(opts = {})
      data, _status_code, _headers = config_get_with_http_info(opts)
      data
    end

    # Get configuration
    # Retrieve the current OpenCode configuration settings and preferences.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @return [Array<(Config, Integer, Hash)>] Config data, response status code and response headers
    def config_get_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.config_get ...'
      end
      # resource path
      local_var_path = '/config'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'directory'] = opts[:'directory'] if !opts[:'directory'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Config'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.config_get",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#config_get\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # List config providers
    # Get a list of all configured AI providers and their default models.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @return [ConfigProviders200Response]
    def config_providers(opts = {})
      data, _status_code, _headers = config_providers_with_http_info(opts)
      data
    end

    # List config providers
    # Get a list of all configured AI providers and their default models.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @return [Array<(ConfigProviders200Response, Integer, Hash)>] ConfigProviders200Response data, response status code and response headers
    def config_providers_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.config_providers ...'
      end
      # resource path
      local_var_path = '/config/providers'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'directory'] = opts[:'directory'] if !opts[:'directory'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'ConfigProviders200Response'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.config_providers",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#config_providers\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update configuration
    # Update OpenCode configuration settings and preferences.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @option opts [Config] :config 
    # @return [Config]
    def config_update(opts = {})
      data, _status_code, _headers = config_update_with_http_info(opts)
      data
    end

    # Update configuration
    # Update OpenCode configuration settings and preferences.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @option opts [Config] :config 
    # @return [Array<(Config, Integer, Hash)>] Config data, response status code and response headers
    def config_update_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.config_update ...'
      end
      # resource path
      local_var_path = '/config'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'directory'] = opts[:'directory'] if !opts[:'directory'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:'config'])

      # return_type
      return_type = opts[:debug_return_type] || 'Config'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.config_update",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#config_update\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Subscribe to events
    # Get events
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @return [Event]
    def event_subscribe(opts = {})
      data, _status_code, _headers = event_subscribe_with_http_info(opts)
      data
    end

    # Subscribe to events
    # Get events
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @return [Array<(Event, Integer, Hash)>] Event data, response status code and response headers
    def event_subscribe_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.event_subscribe ...'
      end
      # resource path
      local_var_path = '/event'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'directory'] = opts[:'directory'] if !opts[:'directory'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['text/event-stream']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Event'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.event_subscribe",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#event_subscribe\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # List files
    # List files and directories in a specified path.
    # @param path [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @return [Array<FileNode>]
    def file_list(path, opts = {})
      data, _status_code, _headers = file_list_with_http_info(path, opts)
      data
    end

    # List files
    # List files and directories in a specified path.
    # @param path [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @return [Array<(Array<FileNode>, Integer, Hash)>] Array<FileNode> data, response status code and response headers
    def file_list_with_http_info(path, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.file_list ...'
      end
      # verify the required parameter 'path' is set
      if @api_client.config.client_side_validation && path.nil?
        fail ArgumentError, "Missing the required parameter 'path' when calling DefaultApi.file_list"
      end
      # resource path
      local_var_path = '/file'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'path'] = path
      query_params[:'directory'] = opts[:'directory'] if !opts[:'directory'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Array<FileNode>'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.file_list",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#file_list\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Read file
    # Read the content of a specified file.
    # @param path [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @return [FileContent]
    def file_read(path, opts = {})
      data, _status_code, _headers = file_read_with_http_info(path, opts)
      data
    end

    # Read file
    # Read the content of a specified file.
    # @param path [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @return [Array<(FileContent, Integer, Hash)>] FileContent data, response status code and response headers
    def file_read_with_http_info(path, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.file_read ...'
      end
      # verify the required parameter 'path' is set
      if @api_client.config.client_side_validation && path.nil?
        fail ArgumentError, "Missing the required parameter 'path' when calling DefaultApi.file_read"
      end
      # resource path
      local_var_path = '/file/content'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'path'] = path
      query_params[:'directory'] = opts[:'directory'] if !opts[:'directory'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'FileContent'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.file_read",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#file_read\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get file status
    # Get the git status of all files in the project.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @return [Array<File>]
    def file_status(opts = {})
      data, _status_code, _headers = file_status_with_http_info(opts)
      data
    end

    # Get file status
    # Get the git status of all files in the project.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @return [Array<(Array<File>, Integer, Hash)>] Array<File> data, response status code and response headers
    def file_status_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.file_status ...'
      end
      # resource path
      local_var_path = '/file/status'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'directory'] = opts[:'directory'] if !opts[:'directory'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Array<File>'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.file_status",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#file_status\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Find files
    # Search for files by name or pattern in the project directory.
    # @param query [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @option opts [String] :dirs 
    # @return [Array<String>]
    def find_files(query, opts = {})
      data, _status_code, _headers = find_files_with_http_info(query, opts)
      data
    end

    # Find files
    # Search for files by name or pattern in the project directory.
    # @param query [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @option opts [String] :dirs 
    # @return [Array<(Array<String>, Integer, Hash)>] Array<String> data, response status code and response headers
    def find_files_with_http_info(query, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.find_files ...'
      end
      # verify the required parameter 'query' is set
      if @api_client.config.client_side_validation && query.nil?
        fail ArgumentError, "Missing the required parameter 'query' when calling DefaultApi.find_files"
      end
      allowable_values = ["true", "false"]
      if @api_client.config.client_side_validation && opts[:'dirs'] && !allowable_values.include?(opts[:'dirs'])
        fail ArgumentError, "invalid value for \"dirs\", must be one of #{allowable_values}"
      end
      # resource path
      local_var_path = '/find/file'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'query'] = query
      query_params[:'directory'] = opts[:'directory'] if !opts[:'directory'].nil?
      query_params[:'dirs'] = opts[:'dirs'] if !opts[:'dirs'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Array<String>'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.find_files",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#find_files\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Find symbols
    # Search for workspace symbols like functions, classes, and variables using LSP.
    # @param query [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @return [Array<Symbol>]
    def find_symbols(query, opts = {})
      data, _status_code, _headers = find_symbols_with_http_info(query, opts)
      data
    end

    # Find symbols
    # Search for workspace symbols like functions, classes, and variables using LSP.
    # @param query [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @return [Array<(Array<Symbol>, Integer, Hash)>] Array<Symbol> data, response status code and response headers
    def find_symbols_with_http_info(query, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.find_symbols ...'
      end
      # verify the required parameter 'query' is set
      if @api_client.config.client_side_validation && query.nil?
        fail ArgumentError, "Missing the required parameter 'query' when calling DefaultApi.find_symbols"
      end
      # resource path
      local_var_path = '/find/symbol'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'query'] = query
      query_params[:'directory'] = opts[:'directory'] if !opts[:'directory'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Array<Symbol>'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.find_symbols",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#find_symbols\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Find text
    # Search for text patterns across files in the project using ripgrep.
    # @param pattern [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @return [Array<FindText200ResponseInner>]
    def find_text(pattern, opts = {})
      data, _status_code, _headers = find_text_with_http_info(pattern, opts)
      data
    end

    # Find text
    # Search for text patterns across files in the project using ripgrep.
    # @param pattern [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @return [Array<(Array<FindText200ResponseInner>, Integer, Hash)>] Array<FindText200ResponseInner> data, response status code and response headers
    def find_text_with_http_info(pattern, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.find_text ...'
      end
      # verify the required parameter 'pattern' is set
      if @api_client.config.client_side_validation && pattern.nil?
        fail ArgumentError, "Missing the required parameter 'pattern' when calling DefaultApi.find_text"
      end
      # resource path
      local_var_path = '/find'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'pattern'] = pattern
      query_params[:'directory'] = opts[:'directory'] if !opts[:'directory'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Array<FindText200ResponseInner>'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.find_text",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#find_text\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get formatter status
    # Get formatter status
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @return [Array<FormatterStatus>]
    def formatter_status(opts = {})
      data, _status_code, _headers = formatter_status_with_http_info(opts)
      data
    end

    # Get formatter status
    # Get formatter status
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @return [Array<(Array<FormatterStatus>, Integer, Hash)>] Array<FormatterStatus> data, response status code and response headers
    def formatter_status_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.formatter_status ...'
      end
      # resource path
      local_var_path = '/formatter'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'directory'] = opts[:'directory'] if !opts[:'directory'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Array<FormatterStatus>'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.formatter_status",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#formatter_status\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Dispose instance
    # Clean up and dispose all OpenCode instances, releasing all resources.
    # @param [Hash] opts the optional parameters
    # @return [Boolean]
    def global_dispose(opts = {})
      data, _status_code, _headers = global_dispose_with_http_info(opts)
      data
    end

    # Dispose instance
    # Clean up and dispose all OpenCode instances, releasing all resources.
    # @param [Hash] opts the optional parameters
    # @return [Array<(Boolean, Integer, Hash)>] Boolean data, response status code and response headers
    def global_dispose_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.global_dispose ...'
      end
      # resource path
      local_var_path = '/global/dispose'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Boolean'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.global_dispose",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#global_dispose\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get global events
    # Subscribe to global events from the OpenCode system using server-sent events.
    # @param [Hash] opts the optional parameters
    # @return [GlobalEvent]
    def global_event(opts = {})
      data, _status_code, _headers = global_event_with_http_info(opts)
      data
    end

    # Get global events
    # Subscribe to global events from the OpenCode system using server-sent events.
    # @param [Hash] opts the optional parameters
    # @return [Array<(GlobalEvent, Integer, Hash)>] GlobalEvent data, response status code and response headers
    def global_event_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.global_event ...'
      end
      # resource path
      local_var_path = '/global/event'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['text/event-stream']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'GlobalEvent'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.global_event",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#global_event\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get health
    # Get health information about the OpenCode server.
    # @param [Hash] opts the optional parameters
    # @return [GlobalHealth200Response]
    def global_health(opts = {})
      data, _status_code, _headers = global_health_with_http_info(opts)
      data
    end

    # Get health
    # Get health information about the OpenCode server.
    # @param [Hash] opts the optional parameters
    # @return [Array<(GlobalHealth200Response, Integer, Hash)>] GlobalHealth200Response data, response status code and response headers
    def global_health_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.global_health ...'
      end
      # resource path
      local_var_path = '/global/health'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'GlobalHealth200Response'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.global_health",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#global_health\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Dispose instance
    # Clean up and dispose the current OpenCode instance, releasing all resources.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @return [Boolean]
    def instance_dispose(opts = {})
      data, _status_code, _headers = instance_dispose_with_http_info(opts)
      data
    end

    # Dispose instance
    # Clean up and dispose the current OpenCode instance, releasing all resources.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @return [Array<(Boolean, Integer, Hash)>] Boolean data, response status code and response headers
    def instance_dispose_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.instance_dispose ...'
      end
      # resource path
      local_var_path = '/instance/dispose'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'directory'] = opts[:'directory'] if !opts[:'directory'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Boolean'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.instance_dispose",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#instance_dispose\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get LSP status
    # Get LSP server status
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @return [Array<LSPStatus>]
    def lsp_status(opts = {})
      data, _status_code, _headers = lsp_status_with_http_info(opts)
      data
    end

    # Get LSP status
    # Get LSP server status
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @return [Array<(Array<LSPStatus>, Integer, Hash)>] Array<LSPStatus> data, response status code and response headers
    def lsp_status_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.lsp_status ...'
      end
      # resource path
      local_var_path = '/lsp'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'directory'] = opts[:'directory'] if !opts[:'directory'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Array<LSPStatus>'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.lsp_status",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#lsp_status\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Add MCP server
    # Dynamically add a new Model Context Protocol (MCP) server to the system.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @option opts [McpAddRequest] :mcp_add_request 
    # @return [Hash<String, MCPStatus>]
    def mcp_add(opts = {})
      data, _status_code, _headers = mcp_add_with_http_info(opts)
      data
    end

    # Add MCP server
    # Dynamically add a new Model Context Protocol (MCP) server to the system.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @option opts [McpAddRequest] :mcp_add_request 
    # @return [Array<(Hash<String, MCPStatus>, Integer, Hash)>] Hash<String, MCPStatus> data, response status code and response headers
    def mcp_add_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.mcp_add ...'
      end
      # resource path
      local_var_path = '/mcp'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'directory'] = opts[:'directory'] if !opts[:'directory'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:'mcp_add_request'])

      # return_type
      return_type = opts[:debug_return_type] || 'Hash<String, MCPStatus>'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.mcp_add",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#mcp_add\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Authenticate MCP OAuth
    # Start OAuth flow and wait for callback (opens browser)
    # @param name [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @return [MCPStatus]
    def mcp_auth_authenticate(name, opts = {})
      data, _status_code, _headers = mcp_auth_authenticate_with_http_info(name, opts)
      data
    end

    # Authenticate MCP OAuth
    # Start OAuth flow and wait for callback (opens browser)
    # @param name [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @return [Array<(MCPStatus, Integer, Hash)>] MCPStatus data, response status code and response headers
    def mcp_auth_authenticate_with_http_info(name, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.mcp_auth_authenticate ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.mcp_auth_authenticate"
      end
      # resource path
      local_var_path = '/mcp/{name}/auth/authenticate'.sub('{' + 'name' + '}', CGI.escape(name.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'directory'] = opts[:'directory'] if !opts[:'directory'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'MCPStatus'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.mcp_auth_authenticate",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#mcp_auth_authenticate\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Complete MCP OAuth
    # Complete OAuth authentication for a Model Context Protocol (MCP) server using the authorization code.
    # @param name [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @option opts [McpAuthCallbackRequest] :mcp_auth_callback_request 
    # @return [MCPStatus]
    def mcp_auth_callback(name, opts = {})
      data, _status_code, _headers = mcp_auth_callback_with_http_info(name, opts)
      data
    end

    # Complete MCP OAuth
    # Complete OAuth authentication for a Model Context Protocol (MCP) server using the authorization code.
    # @param name [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @option opts [McpAuthCallbackRequest] :mcp_auth_callback_request 
    # @return [Array<(MCPStatus, Integer, Hash)>] MCPStatus data, response status code and response headers
    def mcp_auth_callback_with_http_info(name, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.mcp_auth_callback ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.mcp_auth_callback"
      end
      # resource path
      local_var_path = '/mcp/{name}/auth/callback'.sub('{' + 'name' + '}', CGI.escape(name.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'directory'] = opts[:'directory'] if !opts[:'directory'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:'mcp_auth_callback_request'])

      # return_type
      return_type = opts[:debug_return_type] || 'MCPStatus'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.mcp_auth_callback",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#mcp_auth_callback\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Remove MCP OAuth
    # Remove OAuth credentials for an MCP server
    # @param name [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @return [McpAuthRemove200Response]
    def mcp_auth_remove(name, opts = {})
      data, _status_code, _headers = mcp_auth_remove_with_http_info(name, opts)
      data
    end

    # Remove MCP OAuth
    # Remove OAuth credentials for an MCP server
    # @param name [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @return [Array<(McpAuthRemove200Response, Integer, Hash)>] McpAuthRemove200Response data, response status code and response headers
    def mcp_auth_remove_with_http_info(name, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.mcp_auth_remove ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.mcp_auth_remove"
      end
      # resource path
      local_var_path = '/mcp/{name}/auth'.sub('{' + 'name' + '}', CGI.escape(name.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'directory'] = opts[:'directory'] if !opts[:'directory'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'McpAuthRemove200Response'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.mcp_auth_remove",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#mcp_auth_remove\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Start MCP OAuth
    # Start OAuth authentication flow for a Model Context Protocol (MCP) server.
    # @param name [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @return [McpAuthStart200Response]
    def mcp_auth_start(name, opts = {})
      data, _status_code, _headers = mcp_auth_start_with_http_info(name, opts)
      data
    end

    # Start MCP OAuth
    # Start OAuth authentication flow for a Model Context Protocol (MCP) server.
    # @param name [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @return [Array<(McpAuthStart200Response, Integer, Hash)>] McpAuthStart200Response data, response status code and response headers
    def mcp_auth_start_with_http_info(name, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.mcp_auth_start ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.mcp_auth_start"
      end
      # resource path
      local_var_path = '/mcp/{name}/auth'.sub('{' + 'name' + '}', CGI.escape(name.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'directory'] = opts[:'directory'] if !opts[:'directory'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'McpAuthStart200Response'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.mcp_auth_start",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#mcp_auth_start\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Connect an MCP server
    # @param name [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @return [Boolean]
    def mcp_connect(name, opts = {})
      data, _status_code, _headers = mcp_connect_with_http_info(name, opts)
      data
    end

    # Connect an MCP server
    # @param name [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @return [Array<(Boolean, Integer, Hash)>] Boolean data, response status code and response headers
    def mcp_connect_with_http_info(name, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.mcp_connect ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.mcp_connect"
      end
      # resource path
      local_var_path = '/mcp/{name}/connect'.sub('{' + 'name' + '}', CGI.escape(name.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'directory'] = opts[:'directory'] if !opts[:'directory'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Boolean'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.mcp_connect",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#mcp_connect\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Disconnect an MCP server
    # @param name [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @return [Boolean]
    def mcp_disconnect(name, opts = {})
      data, _status_code, _headers = mcp_disconnect_with_http_info(name, opts)
      data
    end

    # Disconnect an MCP server
    # @param name [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @return [Array<(Boolean, Integer, Hash)>] Boolean data, response status code and response headers
    def mcp_disconnect_with_http_info(name, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.mcp_disconnect ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.mcp_disconnect"
      end
      # resource path
      local_var_path = '/mcp/{name}/disconnect'.sub('{' + 'name' + '}', CGI.escape(name.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'directory'] = opts[:'directory'] if !opts[:'directory'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Boolean'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.mcp_disconnect",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#mcp_disconnect\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get MCP status
    # Get the status of all Model Context Protocol (MCP) servers.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @return [Hash<String, MCPStatus>]
    def mcp_status(opts = {})
      data, _status_code, _headers = mcp_status_with_http_info(opts)
      data
    end

    # Get MCP status
    # Get the status of all Model Context Protocol (MCP) servers.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @return [Array<(Hash<String, MCPStatus>, Integer, Hash)>] Hash<String, MCPStatus> data, response status code and response headers
    def mcp_status_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.mcp_status ...'
      end
      # resource path
      local_var_path = '/mcp'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'directory'] = opts[:'directory'] if !opts[:'directory'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Hash<String, MCPStatus>'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.mcp_status",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#mcp_status\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete a part from a message
    # @param session_id [String] Session ID
    # @param message_id [String] Message ID
    # @param part_id [String] Part ID
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @return [Boolean]
    def part_delete(session_id, message_id, part_id, opts = {})
      data, _status_code, _headers = part_delete_with_http_info(session_id, message_id, part_id, opts)
      data
    end

    # Delete a part from a message
    # @param session_id [String] Session ID
    # @param message_id [String] Message ID
    # @param part_id [String] Part ID
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @return [Array<(Boolean, Integer, Hash)>] Boolean data, response status code and response headers
    def part_delete_with_http_info(session_id, message_id, part_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.part_delete ...'
      end
      # verify the required parameter 'session_id' is set
      if @api_client.config.client_side_validation && session_id.nil?
        fail ArgumentError, "Missing the required parameter 'session_id' when calling DefaultApi.part_delete"
      end
      # verify the required parameter 'message_id' is set
      if @api_client.config.client_side_validation && message_id.nil?
        fail ArgumentError, "Missing the required parameter 'message_id' when calling DefaultApi.part_delete"
      end
      # verify the required parameter 'part_id' is set
      if @api_client.config.client_side_validation && part_id.nil?
        fail ArgumentError, "Missing the required parameter 'part_id' when calling DefaultApi.part_delete"
      end
      # resource path
      local_var_path = '/session/{sessionID}/message/{messageID}/part/{partID}'.sub('{' + 'sessionID' + '}', CGI.escape(session_id.to_s)).sub('{' + 'messageID' + '}', CGI.escape(message_id.to_s)).sub('{' + 'partID' + '}', CGI.escape(part_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'directory'] = opts[:'directory'] if !opts[:'directory'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Boolean'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.part_delete",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#part_delete\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update a part in a message
    # @param session_id [String] Session ID
    # @param message_id [String] Message ID
    # @param part_id [String] Part ID
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @option opts [Part] :part 
    # @return [Part]
    def part_update(session_id, message_id, part_id, opts = {})
      data, _status_code, _headers = part_update_with_http_info(session_id, message_id, part_id, opts)
      data
    end

    # Update a part in a message
    # @param session_id [String] Session ID
    # @param message_id [String] Message ID
    # @param part_id [String] Part ID
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @option opts [Part] :part 
    # @return [Array<(Part, Integer, Hash)>] Part data, response status code and response headers
    def part_update_with_http_info(session_id, message_id, part_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.part_update ...'
      end
      # verify the required parameter 'session_id' is set
      if @api_client.config.client_side_validation && session_id.nil?
        fail ArgumentError, "Missing the required parameter 'session_id' when calling DefaultApi.part_update"
      end
      # verify the required parameter 'message_id' is set
      if @api_client.config.client_side_validation && message_id.nil?
        fail ArgumentError, "Missing the required parameter 'message_id' when calling DefaultApi.part_update"
      end
      # verify the required parameter 'part_id' is set
      if @api_client.config.client_side_validation && part_id.nil?
        fail ArgumentError, "Missing the required parameter 'part_id' when calling DefaultApi.part_update"
      end
      # resource path
      local_var_path = '/session/{sessionID}/message/{messageID}/part/{partID}'.sub('{' + 'sessionID' + '}', CGI.escape(session_id.to_s)).sub('{' + 'messageID' + '}', CGI.escape(message_id.to_s)).sub('{' + 'partID' + '}', CGI.escape(part_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'directory'] = opts[:'directory'] if !opts[:'directory'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:'part'])

      # return_type
      return_type = opts[:debug_return_type] || 'Part'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.part_update",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#part_update\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get paths
    # Retrieve the current working directory and related path information for the OpenCode instance.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @return [Path]
    def path_get(opts = {})
      data, _status_code, _headers = path_get_with_http_info(opts)
      data
    end

    # Get paths
    # Retrieve the current working directory and related path information for the OpenCode instance.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @return [Array<(Path, Integer, Hash)>] Path data, response status code and response headers
    def path_get_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.path_get ...'
      end
      # resource path
      local_var_path = '/path'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'directory'] = opts[:'directory'] if !opts[:'directory'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Path'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.path_get",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#path_get\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # List pending permissions
    # Get all pending permission requests across all sessions.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @return [Array<Permission>]
    def permission_list(opts = {})
      data, _status_code, _headers = permission_list_with_http_info(opts)
      data
    end

    # List pending permissions
    # Get all pending permission requests across all sessions.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @return [Array<(Array<Permission>, Integer, Hash)>] Array<Permission> data, response status code and response headers
    def permission_list_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.permission_list ...'
      end
      # resource path
      local_var_path = '/permission'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'directory'] = opts[:'directory'] if !opts[:'directory'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Array<Permission>'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.permission_list",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#permission_list\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Respond to permission
    # Approve or deny a permission request from the AI assistant.
    # @param session_id [String] 
    # @param permission_id [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @option opts [PermissionRespondRequest] :permission_respond_request 
    # @return [Boolean]
    def permission_respond(session_id, permission_id, opts = {})
      data, _status_code, _headers = permission_respond_with_http_info(session_id, permission_id, opts)
      data
    end

    # Respond to permission
    # Approve or deny a permission request from the AI assistant.
    # @param session_id [String] 
    # @param permission_id [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @option opts [PermissionRespondRequest] :permission_respond_request 
    # @return [Array<(Boolean, Integer, Hash)>] Boolean data, response status code and response headers
    def permission_respond_with_http_info(session_id, permission_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.permission_respond ...'
      end
      # verify the required parameter 'session_id' is set
      if @api_client.config.client_side_validation && session_id.nil?
        fail ArgumentError, "Missing the required parameter 'session_id' when calling DefaultApi.permission_respond"
      end
      # verify the required parameter 'permission_id' is set
      if @api_client.config.client_side_validation && permission_id.nil?
        fail ArgumentError, "Missing the required parameter 'permission_id' when calling DefaultApi.permission_respond"
      end
      # resource path
      local_var_path = '/session/{sessionID}/permissions/{permissionID}'.sub('{' + 'sessionID' + '}', CGI.escape(session_id.to_s)).sub('{' + 'permissionID' + '}', CGI.escape(permission_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'directory'] = opts[:'directory'] if !opts[:'directory'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:'permission_respond_request'])

      # return_type
      return_type = opts[:debug_return_type] || 'Boolean'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.permission_respond",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#permission_respond\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get current project
    # Retrieve the currently active project that OpenCode is working with.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @return [Project]
    def project_current(opts = {})
      data, _status_code, _headers = project_current_with_http_info(opts)
      data
    end

    # Get current project
    # Retrieve the currently active project that OpenCode is working with.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @return [Array<(Project, Integer, Hash)>] Project data, response status code and response headers
    def project_current_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.project_current ...'
      end
      # resource path
      local_var_path = '/project/current'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'directory'] = opts[:'directory'] if !opts[:'directory'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Project'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.project_current",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#project_current\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # List all projects
    # Get a list of projects that have been opened with OpenCode.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @return [Array<Project>]
    def project_list(opts = {})
      data, _status_code, _headers = project_list_with_http_info(opts)
      data
    end

    # List all projects
    # Get a list of projects that have been opened with OpenCode.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @return [Array<(Array<Project>, Integer, Hash)>] Array<Project> data, response status code and response headers
    def project_list_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.project_list ...'
      end
      # resource path
      local_var_path = '/project'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'directory'] = opts[:'directory'] if !opts[:'directory'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Array<Project>'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.project_list",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#project_list\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update project
    # Update project properties such as name, icon and color.
    # @param project_id [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @option opts [ProjectUpdateRequest] :project_update_request 
    # @return [Project]
    def project_update(project_id, opts = {})
      data, _status_code, _headers = project_update_with_http_info(project_id, opts)
      data
    end

    # Update project
    # Update project properties such as name, icon and color.
    # @param project_id [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @option opts [ProjectUpdateRequest] :project_update_request 
    # @return [Array<(Project, Integer, Hash)>] Project data, response status code and response headers
    def project_update_with_http_info(project_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.project_update ...'
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling DefaultApi.project_update"
      end
      # resource path
      local_var_path = '/project/{projectID}'.sub('{' + 'projectID' + '}', CGI.escape(project_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'directory'] = opts[:'directory'] if !opts[:'directory'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:'project_update_request'])

      # return_type
      return_type = opts[:debug_return_type] || 'Project'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.project_update",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#project_update\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get provider auth methods
    # Retrieve available authentication methods for all AI providers.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @return [Hash<String, Array<ProviderAuthMethod>>]
    def provider_auth(opts = {})
      data, _status_code, _headers = provider_auth_with_http_info(opts)
      data
    end

    # Get provider auth methods
    # Retrieve available authentication methods for all AI providers.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @return [Array<(Hash<String, Array<ProviderAuthMethod>>, Integer, Hash)>] Hash<String, Array<ProviderAuthMethod>> data, response status code and response headers
    def provider_auth_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.provider_auth ...'
      end
      # resource path
      local_var_path = '/provider/auth'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'directory'] = opts[:'directory'] if !opts[:'directory'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Hash<String, Array<ProviderAuthMethod>>'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.provider_auth",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#provider_auth\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # List providers
    # Get a list of all available AI providers, including both available and connected ones.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @return [ProviderList200Response]
    def provider_list(opts = {})
      data, _status_code, _headers = provider_list_with_http_info(opts)
      data
    end

    # List providers
    # Get a list of all available AI providers, including both available and connected ones.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @return [Array<(ProviderList200Response, Integer, Hash)>] ProviderList200Response data, response status code and response headers
    def provider_list_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.provider_list ...'
      end
      # resource path
      local_var_path = '/provider'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'directory'] = opts[:'directory'] if !opts[:'directory'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'ProviderList200Response'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.provider_list",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#provider_list\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # OAuth authorize
    # Initiate OAuth authorization for a specific AI provider to get an authorization URL.
    # @param provider_id [String] Provider ID
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @option opts [ProviderOauthAuthorizeRequest] :provider_oauth_authorize_request 
    # @return [ProviderAuthAuthorization]
    def provider_oauth_authorize(provider_id, opts = {})
      data, _status_code, _headers = provider_oauth_authorize_with_http_info(provider_id, opts)
      data
    end

    # OAuth authorize
    # Initiate OAuth authorization for a specific AI provider to get an authorization URL.
    # @param provider_id [String] Provider ID
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @option opts [ProviderOauthAuthorizeRequest] :provider_oauth_authorize_request 
    # @return [Array<(ProviderAuthAuthorization, Integer, Hash)>] ProviderAuthAuthorization data, response status code and response headers
    def provider_oauth_authorize_with_http_info(provider_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.provider_oauth_authorize ...'
      end
      # verify the required parameter 'provider_id' is set
      if @api_client.config.client_side_validation && provider_id.nil?
        fail ArgumentError, "Missing the required parameter 'provider_id' when calling DefaultApi.provider_oauth_authorize"
      end
      # resource path
      local_var_path = '/provider/{providerID}/oauth/authorize'.sub('{' + 'providerID' + '}', CGI.escape(provider_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'directory'] = opts[:'directory'] if !opts[:'directory'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:'provider_oauth_authorize_request'])

      # return_type
      return_type = opts[:debug_return_type] || 'ProviderAuthAuthorization'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.provider_oauth_authorize",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#provider_oauth_authorize\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # OAuth callback
    # Handle the OAuth callback from a provider after user authorization.
    # @param provider_id [String] Provider ID
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @option opts [ProviderOauthCallbackRequest] :provider_oauth_callback_request 
    # @return [Boolean]
    def provider_oauth_callback(provider_id, opts = {})
      data, _status_code, _headers = provider_oauth_callback_with_http_info(provider_id, opts)
      data
    end

    # OAuth callback
    # Handle the OAuth callback from a provider after user authorization.
    # @param provider_id [String] Provider ID
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @option opts [ProviderOauthCallbackRequest] :provider_oauth_callback_request 
    # @return [Array<(Boolean, Integer, Hash)>] Boolean data, response status code and response headers
    def provider_oauth_callback_with_http_info(provider_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.provider_oauth_callback ...'
      end
      # verify the required parameter 'provider_id' is set
      if @api_client.config.client_side_validation && provider_id.nil?
        fail ArgumentError, "Missing the required parameter 'provider_id' when calling DefaultApi.provider_oauth_callback"
      end
      # resource path
      local_var_path = '/provider/{providerID}/oauth/callback'.sub('{' + 'providerID' + '}', CGI.escape(provider_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'directory'] = opts[:'directory'] if !opts[:'directory'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:'provider_oauth_callback_request'])

      # return_type
      return_type = opts[:debug_return_type] || 'Boolean'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.provider_oauth_callback",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#provider_oauth_callback\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Connect to PTY session
    # Establish a WebSocket connection to interact with a pseudo-terminal (PTY) session in real-time.
    # @param pty_id [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @return [Boolean]
    def pty_connect(pty_id, opts = {})
      data, _status_code, _headers = pty_connect_with_http_info(pty_id, opts)
      data
    end

    # Connect to PTY session
    # Establish a WebSocket connection to interact with a pseudo-terminal (PTY) session in real-time.
    # @param pty_id [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @return [Array<(Boolean, Integer, Hash)>] Boolean data, response status code and response headers
    def pty_connect_with_http_info(pty_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.pty_connect ...'
      end
      # verify the required parameter 'pty_id' is set
      if @api_client.config.client_side_validation && pty_id.nil?
        fail ArgumentError, "Missing the required parameter 'pty_id' when calling DefaultApi.pty_connect"
      end
      # resource path
      local_var_path = '/pty/{ptyID}/connect'.sub('{' + 'ptyID' + '}', CGI.escape(pty_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'directory'] = opts[:'directory'] if !opts[:'directory'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Boolean'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.pty_connect",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#pty_connect\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Create PTY session
    # Create a new pseudo-terminal (PTY) session for running shell commands and processes.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @option opts [PtyCreateRequest] :pty_create_request 
    # @return [Pty]
    def pty_create(opts = {})
      data, _status_code, _headers = pty_create_with_http_info(opts)
      data
    end

    # Create PTY session
    # Create a new pseudo-terminal (PTY) session for running shell commands and processes.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @option opts [PtyCreateRequest] :pty_create_request 
    # @return [Array<(Pty, Integer, Hash)>] Pty data, response status code and response headers
    def pty_create_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.pty_create ...'
      end
      # resource path
      local_var_path = '/pty'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'directory'] = opts[:'directory'] if !opts[:'directory'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:'pty_create_request'])

      # return_type
      return_type = opts[:debug_return_type] || 'Pty'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.pty_create",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#pty_create\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get PTY session
    # Retrieve detailed information about a specific pseudo-terminal (PTY) session.
    # @param pty_id [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @return [Pty]
    def pty_get(pty_id, opts = {})
      data, _status_code, _headers = pty_get_with_http_info(pty_id, opts)
      data
    end

    # Get PTY session
    # Retrieve detailed information about a specific pseudo-terminal (PTY) session.
    # @param pty_id [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @return [Array<(Pty, Integer, Hash)>] Pty data, response status code and response headers
    def pty_get_with_http_info(pty_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.pty_get ...'
      end
      # verify the required parameter 'pty_id' is set
      if @api_client.config.client_side_validation && pty_id.nil?
        fail ArgumentError, "Missing the required parameter 'pty_id' when calling DefaultApi.pty_get"
      end
      # resource path
      local_var_path = '/pty/{ptyID}'.sub('{' + 'ptyID' + '}', CGI.escape(pty_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'directory'] = opts[:'directory'] if !opts[:'directory'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Pty'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.pty_get",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#pty_get\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # List PTY sessions
    # Get a list of all active pseudo-terminal (PTY) sessions managed by OpenCode.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @return [Array<Pty>]
    def pty_list(opts = {})
      data, _status_code, _headers = pty_list_with_http_info(opts)
      data
    end

    # List PTY sessions
    # Get a list of all active pseudo-terminal (PTY) sessions managed by OpenCode.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @return [Array<(Array<Pty>, Integer, Hash)>] Array<Pty> data, response status code and response headers
    def pty_list_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.pty_list ...'
      end
      # resource path
      local_var_path = '/pty'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'directory'] = opts[:'directory'] if !opts[:'directory'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Array<Pty>'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.pty_list",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#pty_list\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Remove PTY session
    # Remove and terminate a specific pseudo-terminal (PTY) session.
    # @param pty_id [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @return [Boolean]
    def pty_remove(pty_id, opts = {})
      data, _status_code, _headers = pty_remove_with_http_info(pty_id, opts)
      data
    end

    # Remove PTY session
    # Remove and terminate a specific pseudo-terminal (PTY) session.
    # @param pty_id [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @return [Array<(Boolean, Integer, Hash)>] Boolean data, response status code and response headers
    def pty_remove_with_http_info(pty_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.pty_remove ...'
      end
      # verify the required parameter 'pty_id' is set
      if @api_client.config.client_side_validation && pty_id.nil?
        fail ArgumentError, "Missing the required parameter 'pty_id' when calling DefaultApi.pty_remove"
      end
      # resource path
      local_var_path = '/pty/{ptyID}'.sub('{' + 'ptyID' + '}', CGI.escape(pty_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'directory'] = opts[:'directory'] if !opts[:'directory'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Boolean'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.pty_remove",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#pty_remove\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update PTY session
    # Update properties of an existing pseudo-terminal (PTY) session.
    # @param pty_id [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @option opts [PtyUpdateRequest] :pty_update_request 
    # @return [Pty]
    def pty_update(pty_id, opts = {})
      data, _status_code, _headers = pty_update_with_http_info(pty_id, opts)
      data
    end

    # Update PTY session
    # Update properties of an existing pseudo-terminal (PTY) session.
    # @param pty_id [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @option opts [PtyUpdateRequest] :pty_update_request 
    # @return [Array<(Pty, Integer, Hash)>] Pty data, response status code and response headers
    def pty_update_with_http_info(pty_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.pty_update ...'
      end
      # verify the required parameter 'pty_id' is set
      if @api_client.config.client_side_validation && pty_id.nil?
        fail ArgumentError, "Missing the required parameter 'pty_id' when calling DefaultApi.pty_update"
      end
      # resource path
      local_var_path = '/pty/{ptyID}'.sub('{' + 'ptyID' + '}', CGI.escape(pty_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'directory'] = opts[:'directory'] if !opts[:'directory'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:'pty_update_request'])

      # return_type
      return_type = opts[:debug_return_type] || 'Pty'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.pty_update",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PUT, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#pty_update\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Abort session
    # Abort an active session and stop any ongoing AI processing or command execution.
    # @param session_id [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @return [Boolean]
    def session_abort(session_id, opts = {})
      data, _status_code, _headers = session_abort_with_http_info(session_id, opts)
      data
    end

    # Abort session
    # Abort an active session and stop any ongoing AI processing or command execution.
    # @param session_id [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @return [Array<(Boolean, Integer, Hash)>] Boolean data, response status code and response headers
    def session_abort_with_http_info(session_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.session_abort ...'
      end
      # verify the required parameter 'session_id' is set
      if @api_client.config.client_side_validation && session_id.nil?
        fail ArgumentError, "Missing the required parameter 'session_id' when calling DefaultApi.session_abort"
      end
      # resource path
      local_var_path = '/session/{sessionID}/abort'.sub('{' + 'sessionID' + '}', CGI.escape(session_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'directory'] = opts[:'directory'] if !opts[:'directory'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Boolean'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.session_abort",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#session_abort\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Send command
    # Send a new command to a session for execution by the AI assistant.
    # @param session_id [String] Session ID
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @option opts [SessionCommandRequest] :session_command_request 
    # @return [SessionPrompt200Response]
    def session_command(session_id, opts = {})
      data, _status_code, _headers = session_command_with_http_info(session_id, opts)
      data
    end

    # Send command
    # Send a new command to a session for execution by the AI assistant.
    # @param session_id [String] Session ID
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @option opts [SessionCommandRequest] :session_command_request 
    # @return [Array<(SessionPrompt200Response, Integer, Hash)>] SessionPrompt200Response data, response status code and response headers
    def session_command_with_http_info(session_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.session_command ...'
      end
      # verify the required parameter 'session_id' is set
      if @api_client.config.client_side_validation && session_id.nil?
        fail ArgumentError, "Missing the required parameter 'session_id' when calling DefaultApi.session_command"
      end
      # resource path
      local_var_path = '/session/{sessionID}/command'.sub('{' + 'sessionID' + '}', CGI.escape(session_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'directory'] = opts[:'directory'] if !opts[:'directory'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:'session_command_request'])

      # return_type
      return_type = opts[:debug_return_type] || 'SessionPrompt200Response'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.session_command",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#session_command\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Create session
    # Create a new OpenCode session for interacting with AI assistants and managing conversations.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @option opts [SessionCreateRequest] :session_create_request 
    # @return [Session]
    def session_create(opts = {})
      data, _status_code, _headers = session_create_with_http_info(opts)
      data
    end

    # Create session
    # Create a new OpenCode session for interacting with AI assistants and managing conversations.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @option opts [SessionCreateRequest] :session_create_request 
    # @return [Array<(Session, Integer, Hash)>] Session data, response status code and response headers
    def session_create_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.session_create ...'
      end
      # resource path
      local_var_path = '/session'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'directory'] = opts[:'directory'] if !opts[:'directory'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:'session_create_request'])

      # return_type
      return_type = opts[:debug_return_type] || 'Session'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.session_create",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#session_create\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete session
    # Delete a session and permanently remove all associated data, including messages and history.
    # @param session_id [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @return [Boolean]
    def session_delete(session_id, opts = {})
      data, _status_code, _headers = session_delete_with_http_info(session_id, opts)
      data
    end

    # Delete session
    # Delete a session and permanently remove all associated data, including messages and history.
    # @param session_id [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @return [Array<(Boolean, Integer, Hash)>] Boolean data, response status code and response headers
    def session_delete_with_http_info(session_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.session_delete ...'
      end
      # verify the required parameter 'session_id' is set
      if @api_client.config.client_side_validation && session_id.nil?
        fail ArgumentError, "Missing the required parameter 'session_id' when calling DefaultApi.session_delete"
      end
      pattern = Regexp.new(/^ses.*/)
      if @api_client.config.client_side_validation && session_id !~ pattern
        fail ArgumentError, "invalid value for 'session_id' when calling DefaultApi.session_delete, must conform to the pattern #{pattern}."
      end

      # resource path
      local_var_path = '/session/{sessionID}'.sub('{' + 'sessionID' + '}', CGI.escape(session_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'directory'] = opts[:'directory'] if !opts[:'directory'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Boolean'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.session_delete",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#session_delete\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get session diff
    # Get all file changes (diffs) made during this session.
    # @param session_id [String] Session ID
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @option opts [String] :message_id 
    # @return [Array<FileDiff>]
    def session_diff(session_id, opts = {})
      data, _status_code, _headers = session_diff_with_http_info(session_id, opts)
      data
    end

    # Get session diff
    # Get all file changes (diffs) made during this session.
    # @param session_id [String] Session ID
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @option opts [String] :message_id 
    # @return [Array<(Array<FileDiff>, Integer, Hash)>] Array<FileDiff> data, response status code and response headers
    def session_diff_with_http_info(session_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.session_diff ...'
      end
      # verify the required parameter 'session_id' is set
      if @api_client.config.client_side_validation && session_id.nil?
        fail ArgumentError, "Missing the required parameter 'session_id' when calling DefaultApi.session_diff"
      end
      pattern = Regexp.new(/^msg.*/)
      if @api_client.config.client_side_validation && !opts[:'message_id'].nil? && opts[:'message_id'] !~ pattern
        fail ArgumentError, "invalid value for 'opts[:\"message_id\"]' when calling DefaultApi.session_diff, must conform to the pattern #{pattern}."
      end

      # resource path
      local_var_path = '/session/{sessionID}/diff'.sub('{' + 'sessionID' + '}', CGI.escape(session_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'directory'] = opts[:'directory'] if !opts[:'directory'].nil?
      query_params[:'messageID'] = opts[:'message_id'] if !opts[:'message_id'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Array<FileDiff>'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.session_diff",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#session_diff\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Fork session
    # Create a new session by forking an existing session at a specific message point.
    # @param session_id [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @option opts [SessionForkRequest] :session_fork_request 
    # @return [Session]
    def session_fork(session_id, opts = {})
      data, _status_code, _headers = session_fork_with_http_info(session_id, opts)
      data
    end

    # Fork session
    # Create a new session by forking an existing session at a specific message point.
    # @param session_id [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @option opts [SessionForkRequest] :session_fork_request 
    # @return [Array<(Session, Integer, Hash)>] Session data, response status code and response headers
    def session_fork_with_http_info(session_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.session_fork ...'
      end
      # verify the required parameter 'session_id' is set
      if @api_client.config.client_side_validation && session_id.nil?
        fail ArgumentError, "Missing the required parameter 'session_id' when calling DefaultApi.session_fork"
      end
      pattern = Regexp.new(/^ses.*/)
      if @api_client.config.client_side_validation && session_id !~ pattern
        fail ArgumentError, "invalid value for 'session_id' when calling DefaultApi.session_fork, must conform to the pattern #{pattern}."
      end

      # resource path
      local_var_path = '/session/{sessionID}/fork'.sub('{' + 'sessionID' + '}', CGI.escape(session_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'directory'] = opts[:'directory'] if !opts[:'directory'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:'session_fork_request'])

      # return_type
      return_type = opts[:debug_return_type] || 'Session'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.session_fork",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#session_fork\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Initialize session
    # Analyze the current application and create an AGENTS.md file with project-specific agent configurations.
    # @param session_id [String] Session ID
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @option opts [SessionInitRequest] :session_init_request 
    # @return [Boolean]
    def session_init(session_id, opts = {})
      data, _status_code, _headers = session_init_with_http_info(session_id, opts)
      data
    end

    # Initialize session
    # Analyze the current application and create an AGENTS.md file with project-specific agent configurations.
    # @param session_id [String] Session ID
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @option opts [SessionInitRequest] :session_init_request 
    # @return [Array<(Boolean, Integer, Hash)>] Boolean data, response status code and response headers
    def session_init_with_http_info(session_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.session_init ...'
      end
      # verify the required parameter 'session_id' is set
      if @api_client.config.client_side_validation && session_id.nil?
        fail ArgumentError, "Missing the required parameter 'session_id' when calling DefaultApi.session_init"
      end
      # resource path
      local_var_path = '/session/{sessionID}/init'.sub('{' + 'sessionID' + '}', CGI.escape(session_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'directory'] = opts[:'directory'] if !opts[:'directory'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:'session_init_request'])

      # return_type
      return_type = opts[:debug_return_type] || 'Boolean'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.session_init",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#session_init\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # List sessions
    # Get a list of all OpenCode sessions, sorted by most recently updated.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @return [Array<Session>]
    def session_list(opts = {})
      data, _status_code, _headers = session_list_with_http_info(opts)
      data
    end

    # List sessions
    # Get a list of all OpenCode sessions, sorted by most recently updated.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @return [Array<(Array<Session>, Integer, Hash)>] Array<Session> data, response status code and response headers
    def session_list_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.session_list ...'
      end
      # resource path
      local_var_path = '/session'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'directory'] = opts[:'directory'] if !opts[:'directory'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Array<Session>'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.session_list",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#session_list\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get message
    # Retrieve a specific message from a session by its message ID.
    # @param session_id [String] Session ID
    # @param message_id [String] Message ID
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @return [SessionMessages200ResponseInner]
    def session_message(session_id, message_id, opts = {})
      data, _status_code, _headers = session_message_with_http_info(session_id, message_id, opts)
      data
    end

    # Get message
    # Retrieve a specific message from a session by its message ID.
    # @param session_id [String] Session ID
    # @param message_id [String] Message ID
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @return [Array<(SessionMessages200ResponseInner, Integer, Hash)>] SessionMessages200ResponseInner data, response status code and response headers
    def session_message_with_http_info(session_id, message_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.session_message ...'
      end
      # verify the required parameter 'session_id' is set
      if @api_client.config.client_side_validation && session_id.nil?
        fail ArgumentError, "Missing the required parameter 'session_id' when calling DefaultApi.session_message"
      end
      # verify the required parameter 'message_id' is set
      if @api_client.config.client_side_validation && message_id.nil?
        fail ArgumentError, "Missing the required parameter 'message_id' when calling DefaultApi.session_message"
      end
      # resource path
      local_var_path = '/session/{sessionID}/message/{messageID}'.sub('{' + 'sessionID' + '}', CGI.escape(session_id.to_s)).sub('{' + 'messageID' + '}', CGI.escape(message_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'directory'] = opts[:'directory'] if !opts[:'directory'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'SessionMessages200ResponseInner'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.session_message",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#session_message\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get session messages
    # Retrieve all messages in a session, including user prompts and AI responses.
    # @param session_id [String] Session ID
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @option opts [Float] :limit 
    # @return [Array<SessionMessages200ResponseInner>]
    def session_messages(session_id, opts = {})
      data, _status_code, _headers = session_messages_with_http_info(session_id, opts)
      data
    end

    # Get session messages
    # Retrieve all messages in a session, including user prompts and AI responses.
    # @param session_id [String] Session ID
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @option opts [Float] :limit 
    # @return [Array<(Array<SessionMessages200ResponseInner>, Integer, Hash)>] Array<SessionMessages200ResponseInner> data, response status code and response headers
    def session_messages_with_http_info(session_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.session_messages ...'
      end
      # verify the required parameter 'session_id' is set
      if @api_client.config.client_side_validation && session_id.nil?
        fail ArgumentError, "Missing the required parameter 'session_id' when calling DefaultApi.session_messages"
      end
      # resource path
      local_var_path = '/session/{sessionID}/message'.sub('{' + 'sessionID' + '}', CGI.escape(session_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'directory'] = opts[:'directory'] if !opts[:'directory'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Array<SessionMessages200ResponseInner>'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.session_messages",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#session_messages\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Send message
    # Create and send a new message to a session, streaming the AI response.
    # @param session_id [String] Session ID
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @option opts [SessionPromptRequest] :session_prompt_request 
    # @return [SessionPrompt200Response]
    def session_prompt(session_id, opts = {})
      data, _status_code, _headers = session_prompt_with_http_info(session_id, opts)
      data
    end

    # Send message
    # Create and send a new message to a session, streaming the AI response.
    # @param session_id [String] Session ID
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @option opts [SessionPromptRequest] :session_prompt_request 
    # @return [Array<(SessionPrompt200Response, Integer, Hash)>] SessionPrompt200Response data, response status code and response headers
    def session_prompt_with_http_info(session_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.session_prompt ...'
      end
      # verify the required parameter 'session_id' is set
      if @api_client.config.client_side_validation && session_id.nil?
        fail ArgumentError, "Missing the required parameter 'session_id' when calling DefaultApi.session_prompt"
      end
      # resource path
      local_var_path = '/session/{sessionID}/message'.sub('{' + 'sessionID' + '}', CGI.escape(session_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'directory'] = opts[:'directory'] if !opts[:'directory'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:'session_prompt_request'])

      # return_type
      return_type = opts[:debug_return_type] || 'SessionPrompt200Response'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.session_prompt",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#session_prompt\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Send async message
    # Create and send a new message to a session asynchronously, starting the session if needed and returning immediately.
    # @param session_id [String] Session ID
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @option opts [SessionPromptRequest] :session_prompt_request 
    # @return [nil]
    def session_prompt_async(session_id, opts = {})
      session_prompt_async_with_http_info(session_id, opts)
      nil
    end

    # Send async message
    # Create and send a new message to a session asynchronously, starting the session if needed and returning immediately.
    # @param session_id [String] Session ID
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @option opts [SessionPromptRequest] :session_prompt_request 
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def session_prompt_async_with_http_info(session_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.session_prompt_async ...'
      end
      # verify the required parameter 'session_id' is set
      if @api_client.config.client_side_validation && session_id.nil?
        fail ArgumentError, "Missing the required parameter 'session_id' when calling DefaultApi.session_prompt_async"
      end
      # resource path
      local_var_path = '/session/{sessionID}/prompt_async'.sub('{' + 'sessionID' + '}', CGI.escape(session_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'directory'] = opts[:'directory'] if !opts[:'directory'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:'session_prompt_request'])

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.session_prompt_async",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#session_prompt_async\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Revert message
    # Revert a specific message in a session, undoing its effects and restoring the previous state.
    # @param session_id [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @option opts [SessionRevertRequest] :session_revert_request 
    # @return [Session]
    def session_revert(session_id, opts = {})
      data, _status_code, _headers = session_revert_with_http_info(session_id, opts)
      data
    end

    # Revert message
    # Revert a specific message in a session, undoing its effects and restoring the previous state.
    # @param session_id [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @option opts [SessionRevertRequest] :session_revert_request 
    # @return [Array<(Session, Integer, Hash)>] Session data, response status code and response headers
    def session_revert_with_http_info(session_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.session_revert ...'
      end
      # verify the required parameter 'session_id' is set
      if @api_client.config.client_side_validation && session_id.nil?
        fail ArgumentError, "Missing the required parameter 'session_id' when calling DefaultApi.session_revert"
      end
      # resource path
      local_var_path = '/session/{sessionID}/revert'.sub('{' + 'sessionID' + '}', CGI.escape(session_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'directory'] = opts[:'directory'] if !opts[:'directory'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:'session_revert_request'])

      # return_type
      return_type = opts[:debug_return_type] || 'Session'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.session_revert",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#session_revert\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Share session
    # Create a shareable link for a session, allowing others to view the conversation.
    # @param session_id [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @return [Session]
    def session_share(session_id, opts = {})
      data, _status_code, _headers = session_share_with_http_info(session_id, opts)
      data
    end

    # Share session
    # Create a shareable link for a session, allowing others to view the conversation.
    # @param session_id [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @return [Array<(Session, Integer, Hash)>] Session data, response status code and response headers
    def session_share_with_http_info(session_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.session_share ...'
      end
      # verify the required parameter 'session_id' is set
      if @api_client.config.client_side_validation && session_id.nil?
        fail ArgumentError, "Missing the required parameter 'session_id' when calling DefaultApi.session_share"
      end
      # resource path
      local_var_path = '/session/{sessionID}/share'.sub('{' + 'sessionID' + '}', CGI.escape(session_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'directory'] = opts[:'directory'] if !opts[:'directory'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Session'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.session_share",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#session_share\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Run shell command
    # Execute a shell command within the session context and return the AI's response.
    # @param session_id [String] Session ID
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @option opts [SessionShellRequest] :session_shell_request 
    # @return [AssistantMessage]
    def session_shell(session_id, opts = {})
      data, _status_code, _headers = session_shell_with_http_info(session_id, opts)
      data
    end

    # Run shell command
    # Execute a shell command within the session context and return the AI&#39;s response.
    # @param session_id [String] Session ID
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @option opts [SessionShellRequest] :session_shell_request 
    # @return [Array<(AssistantMessage, Integer, Hash)>] AssistantMessage data, response status code and response headers
    def session_shell_with_http_info(session_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.session_shell ...'
      end
      # verify the required parameter 'session_id' is set
      if @api_client.config.client_side_validation && session_id.nil?
        fail ArgumentError, "Missing the required parameter 'session_id' when calling DefaultApi.session_shell"
      end
      # resource path
      local_var_path = '/session/{sessionID}/shell'.sub('{' + 'sessionID' + '}', CGI.escape(session_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'directory'] = opts[:'directory'] if !opts[:'directory'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:'session_shell_request'])

      # return_type
      return_type = opts[:debug_return_type] || 'AssistantMessage'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.session_shell",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#session_shell\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get session status
    # Retrieve the current status of all sessions, including active, idle, and completed states.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @return [Hash<String, SessionStatus>]
    def session_status(opts = {})
      data, _status_code, _headers = session_status_with_http_info(opts)
      data
    end

    # Get session status
    # Retrieve the current status of all sessions, including active, idle, and completed states.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @return [Array<(Hash<String, SessionStatus>, Integer, Hash)>] Hash<String, SessionStatus> data, response status code and response headers
    def session_status_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.session_status ...'
      end
      # resource path
      local_var_path = '/session/status'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'directory'] = opts[:'directory'] if !opts[:'directory'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Hash<String, SessionStatus>'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.session_status",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#session_status\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Summarize session
    # Generate a concise summary of the session using AI compaction to preserve key information.
    # @param session_id [String] Session ID
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @option opts [SessionSummarizeRequest] :session_summarize_request 
    # @return [Boolean]
    def session_summarize(session_id, opts = {})
      data, _status_code, _headers = session_summarize_with_http_info(session_id, opts)
      data
    end

    # Summarize session
    # Generate a concise summary of the session using AI compaction to preserve key information.
    # @param session_id [String] Session ID
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @option opts [SessionSummarizeRequest] :session_summarize_request 
    # @return [Array<(Boolean, Integer, Hash)>] Boolean data, response status code and response headers
    def session_summarize_with_http_info(session_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.session_summarize ...'
      end
      # verify the required parameter 'session_id' is set
      if @api_client.config.client_side_validation && session_id.nil?
        fail ArgumentError, "Missing the required parameter 'session_id' when calling DefaultApi.session_summarize"
      end
      # resource path
      local_var_path = '/session/{sessionID}/summarize'.sub('{' + 'sessionID' + '}', CGI.escape(session_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'directory'] = opts[:'directory'] if !opts[:'directory'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:'session_summarize_request'])

      # return_type
      return_type = opts[:debug_return_type] || 'Boolean'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.session_summarize",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#session_summarize\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get session todos
    # Retrieve the todo list associated with a specific session, showing tasks and action items.
    # @param session_id [String] Session ID
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @return [Array<Todo>]
    def session_todo(session_id, opts = {})
      data, _status_code, _headers = session_todo_with_http_info(session_id, opts)
      data
    end

    # Get session todos
    # Retrieve the todo list associated with a specific session, showing tasks and action items.
    # @param session_id [String] Session ID
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @return [Array<(Array<Todo>, Integer, Hash)>] Array<Todo> data, response status code and response headers
    def session_todo_with_http_info(session_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.session_todo ...'
      end
      # verify the required parameter 'session_id' is set
      if @api_client.config.client_side_validation && session_id.nil?
        fail ArgumentError, "Missing the required parameter 'session_id' when calling DefaultApi.session_todo"
      end
      # resource path
      local_var_path = '/session/{sessionID}/todo'.sub('{' + 'sessionID' + '}', CGI.escape(session_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'directory'] = opts[:'directory'] if !opts[:'directory'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Array<Todo>'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.session_todo",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#session_todo\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Restore reverted messages
    # Restore all previously reverted messages in a session.
    # @param session_id [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @return [Session]
    def session_unrevert(session_id, opts = {})
      data, _status_code, _headers = session_unrevert_with_http_info(session_id, opts)
      data
    end

    # Restore reverted messages
    # Restore all previously reverted messages in a session.
    # @param session_id [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @return [Array<(Session, Integer, Hash)>] Session data, response status code and response headers
    def session_unrevert_with_http_info(session_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.session_unrevert ...'
      end
      # verify the required parameter 'session_id' is set
      if @api_client.config.client_side_validation && session_id.nil?
        fail ArgumentError, "Missing the required parameter 'session_id' when calling DefaultApi.session_unrevert"
      end
      # resource path
      local_var_path = '/session/{sessionID}/unrevert'.sub('{' + 'sessionID' + '}', CGI.escape(session_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'directory'] = opts[:'directory'] if !opts[:'directory'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Session'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.session_unrevert",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#session_unrevert\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Unshare session
    # Remove the shareable link for a session, making it private again.
    # @param session_id [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @return [Session]
    def session_unshare(session_id, opts = {})
      data, _status_code, _headers = session_unshare_with_http_info(session_id, opts)
      data
    end

    # Unshare session
    # Remove the shareable link for a session, making it private again.
    # @param session_id [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @return [Array<(Session, Integer, Hash)>] Session data, response status code and response headers
    def session_unshare_with_http_info(session_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.session_unshare ...'
      end
      # verify the required parameter 'session_id' is set
      if @api_client.config.client_side_validation && session_id.nil?
        fail ArgumentError, "Missing the required parameter 'session_id' when calling DefaultApi.session_unshare"
      end
      pattern = Regexp.new(/^ses.*/)
      if @api_client.config.client_side_validation && session_id !~ pattern
        fail ArgumentError, "invalid value for 'session_id' when calling DefaultApi.session_unshare, must conform to the pattern #{pattern}."
      end

      # resource path
      local_var_path = '/session/{sessionID}/share'.sub('{' + 'sessionID' + '}', CGI.escape(session_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'directory'] = opts[:'directory'] if !opts[:'directory'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Session'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.session_unshare",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#session_unshare\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update session
    # Update properties of an existing session, such as title or other metadata.
    # @param session_id [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @option opts [SessionUpdateRequest] :session_update_request 
    # @return [Session]
    def session_update(session_id, opts = {})
      data, _status_code, _headers = session_update_with_http_info(session_id, opts)
      data
    end

    # Update session
    # Update properties of an existing session, such as title or other metadata.
    # @param session_id [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @option opts [SessionUpdateRequest] :session_update_request 
    # @return [Array<(Session, Integer, Hash)>] Session data, response status code and response headers
    def session_update_with_http_info(session_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.session_update ...'
      end
      # verify the required parameter 'session_id' is set
      if @api_client.config.client_side_validation && session_id.nil?
        fail ArgumentError, "Missing the required parameter 'session_id' when calling DefaultApi.session_update"
      end
      # resource path
      local_var_path = '/session/{sessionID}'.sub('{' + 'sessionID' + '}', CGI.escape(session_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'directory'] = opts[:'directory'] if !opts[:'directory'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:'session_update_request'])

      # return_type
      return_type = opts[:debug_return_type] || 'Session'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.session_update",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#session_update\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # List tool IDs
    # Get a list of all available tool IDs, including both built-in tools and dynamically registered tools.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @return [Array<String>]
    def tool_ids(opts = {})
      data, _status_code, _headers = tool_ids_with_http_info(opts)
      data
    end

    # List tool IDs
    # Get a list of all available tool IDs, including both built-in tools and dynamically registered tools.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @return [Array<(Array<String>, Integer, Hash)>] Array<String> data, response status code and response headers
    def tool_ids_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.tool_ids ...'
      end
      # resource path
      local_var_path = '/experimental/tool/ids'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'directory'] = opts[:'directory'] if !opts[:'directory'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Array<String>'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.tool_ids",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#tool_ids\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # List tools
    # Get a list of available tools with their JSON schema parameters for a specific provider and model combination.
    # @param provider [String] 
    # @param model [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @return [Array<ToolListItem>]
    def tool_list(provider, model, opts = {})
      data, _status_code, _headers = tool_list_with_http_info(provider, model, opts)
      data
    end

    # List tools
    # Get a list of available tools with their JSON schema parameters for a specific provider and model combination.
    # @param provider [String] 
    # @param model [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @return [Array<(Array<ToolListItem>, Integer, Hash)>] Array<ToolListItem> data, response status code and response headers
    def tool_list_with_http_info(provider, model, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.tool_list ...'
      end
      # verify the required parameter 'provider' is set
      if @api_client.config.client_side_validation && provider.nil?
        fail ArgumentError, "Missing the required parameter 'provider' when calling DefaultApi.tool_list"
      end
      # verify the required parameter 'model' is set
      if @api_client.config.client_side_validation && model.nil?
        fail ArgumentError, "Missing the required parameter 'model' when calling DefaultApi.tool_list"
      end
      # resource path
      local_var_path = '/experimental/tool'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'provider'] = provider
      query_params[:'model'] = model
      query_params[:'directory'] = opts[:'directory'] if !opts[:'directory'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Array<ToolListItem>'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.tool_list",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#tool_list\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Append TUI prompt
    # Append prompt to the TUI
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @option opts [FindText200ResponseInnerPath] :find_text200_response_inner_path 
    # @return [Boolean]
    def tui_append_prompt(opts = {})
      data, _status_code, _headers = tui_append_prompt_with_http_info(opts)
      data
    end

    # Append TUI prompt
    # Append prompt to the TUI
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @option opts [FindText200ResponseInnerPath] :find_text200_response_inner_path 
    # @return [Array<(Boolean, Integer, Hash)>] Boolean data, response status code and response headers
    def tui_append_prompt_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.tui_append_prompt ...'
      end
      # resource path
      local_var_path = '/tui/append-prompt'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'directory'] = opts[:'directory'] if !opts[:'directory'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:'find_text200_response_inner_path'])

      # return_type
      return_type = opts[:debug_return_type] || 'Boolean'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.tui_append_prompt",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#tui_append_prompt\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Clear TUI prompt
    # Clear the prompt
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @return [Boolean]
    def tui_clear_prompt(opts = {})
      data, _status_code, _headers = tui_clear_prompt_with_http_info(opts)
      data
    end

    # Clear TUI prompt
    # Clear the prompt
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @return [Array<(Boolean, Integer, Hash)>] Boolean data, response status code and response headers
    def tui_clear_prompt_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.tui_clear_prompt ...'
      end
      # resource path
      local_var_path = '/tui/clear-prompt'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'directory'] = opts[:'directory'] if !opts[:'directory'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Boolean'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.tui_clear_prompt",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#tui_clear_prompt\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get next TUI request
    # Retrieve the next TUI (Terminal User Interface) request from the queue for processing.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @return [TuiControlNext200Response]
    def tui_control_next(opts = {})
      data, _status_code, _headers = tui_control_next_with_http_info(opts)
      data
    end

    # Get next TUI request
    # Retrieve the next TUI (Terminal User Interface) request from the queue for processing.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @return [Array<(TuiControlNext200Response, Integer, Hash)>] TuiControlNext200Response data, response status code and response headers
    def tui_control_next_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.tui_control_next ...'
      end
      # resource path
      local_var_path = '/tui/control/next'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'directory'] = opts[:'directory'] if !opts[:'directory'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'TuiControlNext200Response'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.tui_control_next",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#tui_control_next\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Submit TUI response
    # Submit a response to the TUI request queue to complete a pending request.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @option opts [Object] :body 
    # @return [Boolean]
    def tui_control_response(opts = {})
      data, _status_code, _headers = tui_control_response_with_http_info(opts)
      data
    end

    # Submit TUI response
    # Submit a response to the TUI request queue to complete a pending request.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @option opts [Object] :body 
    # @return [Array<(Boolean, Integer, Hash)>] Boolean data, response status code and response headers
    def tui_control_response_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.tui_control_response ...'
      end
      # resource path
      local_var_path = '/tui/control/response'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'directory'] = opts[:'directory'] if !opts[:'directory'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:'body'])

      # return_type
      return_type = opts[:debug_return_type] || 'Boolean'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.tui_control_response",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#tui_control_response\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Execute TUI command
    # Execute a TUI command (e.g. agent_cycle)
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @option opts [TuiExecuteCommandRequest] :tui_execute_command_request 
    # @return [Boolean]
    def tui_execute_command(opts = {})
      data, _status_code, _headers = tui_execute_command_with_http_info(opts)
      data
    end

    # Execute TUI command
    # Execute a TUI command (e.g. agent_cycle)
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @option opts [TuiExecuteCommandRequest] :tui_execute_command_request 
    # @return [Array<(Boolean, Integer, Hash)>] Boolean data, response status code and response headers
    def tui_execute_command_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.tui_execute_command ...'
      end
      # resource path
      local_var_path = '/tui/execute-command'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'directory'] = opts[:'directory'] if !opts[:'directory'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:'tui_execute_command_request'])

      # return_type
      return_type = opts[:debug_return_type] || 'Boolean'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.tui_execute_command",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#tui_execute_command\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Open help dialog
    # Open the help dialog in the TUI to display user assistance information.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @return [Boolean]
    def tui_open_help(opts = {})
      data, _status_code, _headers = tui_open_help_with_http_info(opts)
      data
    end

    # Open help dialog
    # Open the help dialog in the TUI to display user assistance information.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @return [Array<(Boolean, Integer, Hash)>] Boolean data, response status code and response headers
    def tui_open_help_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.tui_open_help ...'
      end
      # resource path
      local_var_path = '/tui/open-help'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'directory'] = opts[:'directory'] if !opts[:'directory'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Boolean'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.tui_open_help",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#tui_open_help\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Open models dialog
    # Open the model dialog
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @return [Boolean]
    def tui_open_models(opts = {})
      data, _status_code, _headers = tui_open_models_with_http_info(opts)
      data
    end

    # Open models dialog
    # Open the model dialog
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @return [Array<(Boolean, Integer, Hash)>] Boolean data, response status code and response headers
    def tui_open_models_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.tui_open_models ...'
      end
      # resource path
      local_var_path = '/tui/open-models'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'directory'] = opts[:'directory'] if !opts[:'directory'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Boolean'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.tui_open_models",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#tui_open_models\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Open sessions dialog
    # Open the session dialog
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @return [Boolean]
    def tui_open_sessions(opts = {})
      data, _status_code, _headers = tui_open_sessions_with_http_info(opts)
      data
    end

    # Open sessions dialog
    # Open the session dialog
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @return [Array<(Boolean, Integer, Hash)>] Boolean data, response status code and response headers
    def tui_open_sessions_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.tui_open_sessions ...'
      end
      # resource path
      local_var_path = '/tui/open-sessions'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'directory'] = opts[:'directory'] if !opts[:'directory'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Boolean'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.tui_open_sessions",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#tui_open_sessions\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Open themes dialog
    # Open the theme dialog
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @return [Boolean]
    def tui_open_themes(opts = {})
      data, _status_code, _headers = tui_open_themes_with_http_info(opts)
      data
    end

    # Open themes dialog
    # Open the theme dialog
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @return [Array<(Boolean, Integer, Hash)>] Boolean data, response status code and response headers
    def tui_open_themes_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.tui_open_themes ...'
      end
      # resource path
      local_var_path = '/tui/open-themes'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'directory'] = opts[:'directory'] if !opts[:'directory'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Boolean'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.tui_open_themes",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#tui_open_themes\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Publish TUI event
    # Publish a TUI event
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @option opts [TuiPublishRequest] :tui_publish_request 
    # @return [Boolean]
    def tui_publish(opts = {})
      data, _status_code, _headers = tui_publish_with_http_info(opts)
      data
    end

    # Publish TUI event
    # Publish a TUI event
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @option opts [TuiPublishRequest] :tui_publish_request 
    # @return [Array<(Boolean, Integer, Hash)>] Boolean data, response status code and response headers
    def tui_publish_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.tui_publish ...'
      end
      # resource path
      local_var_path = '/tui/publish'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'directory'] = opts[:'directory'] if !opts[:'directory'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:'tui_publish_request'])

      # return_type
      return_type = opts[:debug_return_type] || 'Boolean'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.tui_publish",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#tui_publish\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Show TUI toast
    # Show a toast notification in the TUI
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @option opts [TuiShowToastRequest] :tui_show_toast_request 
    # @return [Boolean]
    def tui_show_toast(opts = {})
      data, _status_code, _headers = tui_show_toast_with_http_info(opts)
      data
    end

    # Show TUI toast
    # Show a toast notification in the TUI
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @option opts [TuiShowToastRequest] :tui_show_toast_request 
    # @return [Array<(Boolean, Integer, Hash)>] Boolean data, response status code and response headers
    def tui_show_toast_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.tui_show_toast ...'
      end
      # resource path
      local_var_path = '/tui/show-toast'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'directory'] = opts[:'directory'] if !opts[:'directory'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:'tui_show_toast_request'])

      # return_type
      return_type = opts[:debug_return_type] || 'Boolean'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.tui_show_toast",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#tui_show_toast\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Submit TUI prompt
    # Submit the prompt
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @return [Boolean]
    def tui_submit_prompt(opts = {})
      data, _status_code, _headers = tui_submit_prompt_with_http_info(opts)
      data
    end

    # Submit TUI prompt
    # Submit the prompt
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @return [Array<(Boolean, Integer, Hash)>] Boolean data, response status code and response headers
    def tui_submit_prompt_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.tui_submit_prompt ...'
      end
      # resource path
      local_var_path = '/tui/submit-prompt'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'directory'] = opts[:'directory'] if !opts[:'directory'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Boolean'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.tui_submit_prompt",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#tui_submit_prompt\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get VCS info
    # Retrieve version control system (VCS) information for the current project, such as git branch.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @return [VcsInfo]
    def vcs_get(opts = {})
      data, _status_code, _headers = vcs_get_with_http_info(opts)
      data
    end

    # Get VCS info
    # Retrieve version control system (VCS) information for the current project, such as git branch.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :directory 
    # @return [Array<(VcsInfo, Integer, Hash)>] VcsInfo data, response status code and response headers
    def vcs_get_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.vcs_get ...'
      end
      # resource path
      local_var_path = '/vcs'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'directory'] = opts[:'directory'] if !opts[:'directory'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'VcsInfo'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.vcs_get",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#vcs_get\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
  end
end
