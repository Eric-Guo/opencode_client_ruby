=begin
#opencode

#opencode api

The version of the OpenAPI document: 1.0.0

Generated by: https://openapi-generator.tech
Generator version: 7.18.0

=end

require 'date'
require 'time'

module OpencodeClient
  class Config < ApiModelBase
    # JSON schema reference for configuration validation
    attr_accessor :schema

    # Theme name to use for the interface
    attr_accessor :theme

    attr_accessor :keybinds

    attr_accessor :log_level

    attr_accessor :tui

    attr_accessor :server

    # Command configuration, see https://opencode.ai/docs/commands
    attr_accessor :command

    attr_accessor :watcher

    attr_accessor :plugin

    attr_accessor :snapshot

    # Control sharing behavior:'manual' allows manual sharing via commands, 'auto' enables automatic sharing, 'disabled' disables all sharing
    attr_accessor :share

    # @deprecated Use 'share' field instead. Share newly created sessions automatically
    attr_accessor :autoshare

    attr_accessor :autoupdate

    # Disable providers that are loaded automatically
    attr_accessor :disabled_providers

    # When set, ONLY these providers will be enabled. All other providers will be ignored
    attr_accessor :enabled_providers

    # Model to use in the format of provider/model, eg anthropic/claude-2
    attr_accessor :model

    # Small model to use for tasks like title generation in the format of provider/model
    attr_accessor :small_model

    # Default agent to use when none is specified. Must be a primary agent. Falls back to 'build' if not set or if the specified agent is invalid.
    attr_accessor :default_agent

    # Custom username to display in conversations instead of system username
    attr_accessor :username

    # THAPE clerk code. Auto-populated from SSO when available
    attr_accessor :clerk_code

    attr_accessor :mode

    attr_accessor :agent

    # Custom provider configurations and model overrides
    attr_accessor :provider

    # MCP (Model Context Protocol) server configurations
    attr_accessor :mcp

    attr_accessor :formatter

    attr_accessor :lsp

    # Additional instruction files or patterns to include
    attr_accessor :instructions

    attr_accessor :layout

    attr_accessor :permission

    attr_accessor :tools

    attr_accessor :enterprise

    attr_accessor :compaction

    attr_accessor :experimental

    class EnumAttributeValidator
      attr_reader :datatype
      attr_reader :allowable_values

      def initialize(datatype, allowable_values)
        @allowable_values = allowable_values.map do |value|
          case datatype.to_s
          when /Integer/i
            value.to_i
          when /Float/i
            value.to_f
          else
            value
          end
        end
      end

      def valid?(value)
        !value || allowable_values.include?(value)
      end
    end

    # Attribute mapping from ruby-style variable name to JSON key.
    def self.attribute_map
      {
        :'schema' => :'$schema',
        :'theme' => :'theme',
        :'keybinds' => :'keybinds',
        :'log_level' => :'logLevel',
        :'tui' => :'tui',
        :'server' => :'server',
        :'command' => :'command',
        :'watcher' => :'watcher',
        :'plugin' => :'plugin',
        :'snapshot' => :'snapshot',
        :'share' => :'share',
        :'autoshare' => :'autoshare',
        :'autoupdate' => :'autoupdate',
        :'disabled_providers' => :'disabled_providers',
        :'enabled_providers' => :'enabled_providers',
        :'model' => :'model',
        :'small_model' => :'small_model',
        :'default_agent' => :'default_agent',
        :'username' => :'username',
        :'clerk_code' => :'clerk_code',
        :'mode' => :'mode',
        :'agent' => :'agent',
        :'provider' => :'provider',
        :'mcp' => :'mcp',
        :'formatter' => :'formatter',
        :'lsp' => :'lsp',
        :'instructions' => :'instructions',
        :'layout' => :'layout',
        :'permission' => :'permission',
        :'tools' => :'tools',
        :'enterprise' => :'enterprise',
        :'compaction' => :'compaction',
        :'experimental' => :'experimental'
      }
    end

    # Returns attribute mapping this model knows about
    def self.acceptable_attribute_map
      attribute_map
    end

    # Returns all the JSON keys this model knows about
    def self.acceptable_attributes
      acceptable_attribute_map.values
    end

    # Attribute type mapping.
    def self.openapi_types
      {
        :'schema' => :'String',
        :'theme' => :'String',
        :'keybinds' => :'KeybindsConfig',
        :'log_level' => :'LogLevel',
        :'tui' => :'ConfigTui',
        :'server' => :'ServerConfig',
        :'command' => :'Hash<String, ConfigCommandValue>',
        :'watcher' => :'ConfigWatcher',
        :'plugin' => :'Array<String>',
        :'snapshot' => :'Boolean',
        :'share' => :'String',
        :'autoshare' => :'Boolean',
        :'autoupdate' => :'ConfigAutoupdate',
        :'disabled_providers' => :'Array<String>',
        :'enabled_providers' => :'Array<String>',
        :'model' => :'String',
        :'small_model' => :'String',
        :'default_agent' => :'String',
        :'username' => :'String',
        :'clerk_code' => :'String',
        :'mode' => :'ConfigMode',
        :'agent' => :'ConfigAgent',
        :'provider' => :'Hash<String, ProviderConfig>',
        :'mcp' => :'Hash<String, McpAddRequestConfig>',
        :'formatter' => :'ConfigFormatter',
        :'lsp' => :'ConfigLsp',
        :'instructions' => :'Array<String>',
        :'layout' => :'LayoutConfig',
        :'permission' => :'AgentConfigPermission',
        :'tools' => :'Hash<String, Boolean>',
        :'enterprise' => :'ConfigEnterprise',
        :'compaction' => :'ConfigCompaction',
        :'experimental' => :'ConfigExperimental'
      }
    end

    # List of attributes with nullable: true
    def self.openapi_nullable
      Set.new([
      ])
    end

    # Initializes the object
    # @param [Hash] attributes Model attributes in the form of hash
    def initialize(attributes = {})
      if (!attributes.is_a?(Hash))
        fail ArgumentError, "The input argument (attributes) must be a hash in `OpencodeClient::Config` initialize method"
      end

      # check to see if the attribute exists and convert string to symbol for hash key
      acceptable_attribute_map = self.class.acceptable_attribute_map
      attributes = attributes.each_with_object({}) { |(k, v), h|
        if (!acceptable_attribute_map.key?(k.to_sym))
          fail ArgumentError, "`#{k}` is not a valid attribute in `OpencodeClient::Config`. Please check the name to make sure it's valid. List of attributes: " + acceptable_attribute_map.keys.inspect
        end
        h[k.to_sym] = v
      }

      if attributes.key?(:'schema')
        self.schema = attributes[:'schema']
      end

      if attributes.key?(:'theme')
        self.theme = attributes[:'theme']
      end

      if attributes.key?(:'keybinds')
        self.keybinds = attributes[:'keybinds']
      end

      if attributes.key?(:'log_level')
        self.log_level = attributes[:'log_level']
      end

      if attributes.key?(:'tui')
        self.tui = attributes[:'tui']
      end

      if attributes.key?(:'server')
        self.server = attributes[:'server']
      end

      if attributes.key?(:'command')
        if (value = attributes[:'command']).is_a?(Hash)
          self.command = value
        end
      end

      if attributes.key?(:'watcher')
        self.watcher = attributes[:'watcher']
      end

      if attributes.key?(:'plugin')
        if (value = attributes[:'plugin']).is_a?(Array)
          self.plugin = value
        end
      end

      if attributes.key?(:'snapshot')
        self.snapshot = attributes[:'snapshot']
      end

      if attributes.key?(:'share')
        self.share = attributes[:'share']
      end

      if attributes.key?(:'autoshare')
        self.autoshare = attributes[:'autoshare']
      end

      if attributes.key?(:'autoupdate')
        self.autoupdate = attributes[:'autoupdate']
      end

      if attributes.key?(:'disabled_providers')
        if (value = attributes[:'disabled_providers']).is_a?(Array)
          self.disabled_providers = value
        end
      end

      if attributes.key?(:'enabled_providers')
        if (value = attributes[:'enabled_providers']).is_a?(Array)
          self.enabled_providers = value
        end
      end

      if attributes.key?(:'model')
        self.model = attributes[:'model']
      end

      if attributes.key?(:'small_model')
        self.small_model = attributes[:'small_model']
      end

      if attributes.key?(:'default_agent')
        self.default_agent = attributes[:'default_agent']
      end

      if attributes.key?(:'username')
        self.username = attributes[:'username']
      end

      if attributes.key?(:'clerk_code')
        self.clerk_code = attributes[:'clerk_code']
      end

      if attributes.key?(:'mode')
        self.mode = attributes[:'mode']
      end

      if attributes.key?(:'agent')
        self.agent = attributes[:'agent']
      end

      if attributes.key?(:'provider')
        if (value = attributes[:'provider']).is_a?(Hash)
          self.provider = value
        end
      end

      if attributes.key?(:'mcp')
        if (value = attributes[:'mcp']).is_a?(Hash)
          self.mcp = value
        end
      end

      if attributes.key?(:'formatter')
        self.formatter = attributes[:'formatter']
      end

      if attributes.key?(:'lsp')
        self.lsp = attributes[:'lsp']
      end

      if attributes.key?(:'instructions')
        if (value = attributes[:'instructions']).is_a?(Array)
          self.instructions = value
        end
      end

      if attributes.key?(:'layout')
        self.layout = attributes[:'layout']
      end

      if attributes.key?(:'permission')
        self.permission = attributes[:'permission']
      end

      if attributes.key?(:'tools')
        if (value = attributes[:'tools']).is_a?(Hash)
          self.tools = value
        end
      end

      if attributes.key?(:'enterprise')
        self.enterprise = attributes[:'enterprise']
      end

      if attributes.key?(:'compaction')
        self.compaction = attributes[:'compaction']
      end

      if attributes.key?(:'experimental')
        self.experimental = attributes[:'experimental']
      end
    end

    # Show invalid properties with the reasons. Usually used together with valid?
    # @return Array for valid properties with the reasons
    def list_invalid_properties
      warn '[DEPRECATED] the `list_invalid_properties` method is obsolete'
      invalid_properties = Array.new
      invalid_properties
    end

    # Check to see if the all the properties in the model are valid
    # @return true if the model is valid
    def valid?
      warn '[DEPRECATED] the `valid?` method is obsolete'
      share_validator = EnumAttributeValidator.new('String', ["manual", "auto", "disabled"])
      return false unless share_validator.valid?(@share)
      true
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] share Object to be assigned
    def share=(share)
      validator = EnumAttributeValidator.new('String', ["manual", "auto", "disabled"])
      unless validator.valid?(share)
        fail ArgumentError, "invalid value for \"share\", must be one of #{validator.allowable_values}."
      end
      @share = share
    end

    # Checks equality by comparing each attribute.
    # @param [Object] Object to be compared
    def ==(o)
      return true if self.equal?(o)
      self.class == o.class &&
          schema == o.schema &&
          theme == o.theme &&
          keybinds == o.keybinds &&
          log_level == o.log_level &&
          tui == o.tui &&
          server == o.server &&
          command == o.command &&
          watcher == o.watcher &&
          plugin == o.plugin &&
          snapshot == o.snapshot &&
          share == o.share &&
          autoshare == o.autoshare &&
          autoupdate == o.autoupdate &&
          disabled_providers == o.disabled_providers &&
          enabled_providers == o.enabled_providers &&
          model == o.model &&
          small_model == o.small_model &&
          default_agent == o.default_agent &&
          username == o.username &&
          clerk_code == o.clerk_code &&
          mode == o.mode &&
          agent == o.agent &&
          provider == o.provider &&
          mcp == o.mcp &&
          formatter == o.formatter &&
          lsp == o.lsp &&
          instructions == o.instructions &&
          layout == o.layout &&
          permission == o.permission &&
          tools == o.tools &&
          enterprise == o.enterprise &&
          compaction == o.compaction &&
          experimental == o.experimental
    end

    # @see the `==` method
    # @param [Object] Object to be compared
    def eql?(o)
      self == o
    end

    # Calculates hash code according to all attributes.
    # @return [Integer] Hash code
    def hash
      [schema, theme, keybinds, log_level, tui, server, command, watcher, plugin, snapshot, share, autoshare, autoupdate, disabled_providers, enabled_providers, model, small_model, default_agent, username, clerk_code, mode, agent, provider, mcp, formatter, lsp, instructions, layout, permission, tools, enterprise, compaction, experimental].hash
    end

    # Builds the object from hash
    # @param [Hash] attributes Model attributes in the form of hash
    # @return [Object] Returns the model itself
    def self.build_from_hash(attributes)
      return nil unless attributes.is_a?(Hash)
      attributes = attributes.transform_keys(&:to_sym)
      transformed_hash = {}
      openapi_types.each_pair do |key, type|
        if attributes.key?(attribute_map[key]) && attributes[attribute_map[key]].nil?
          transformed_hash["#{key}"] = nil
        elsif type =~ /\AArray<(.*)>/i
          # check to ensure the input is an array given that the attribute
          # is documented as an array but the input is not
          if attributes[attribute_map[key]].is_a?(Array)
            transformed_hash["#{key}"] = attributes[attribute_map[key]].map { |v| _deserialize($1, v) }
          end
        elsif !attributes[attribute_map[key]].nil?
          transformed_hash["#{key}"] = _deserialize(type, attributes[attribute_map[key]])
        end
      end
      new(transformed_hash)
    end

    # Returns the object in the form of hash
    # @return [Hash] Returns the object in the form of hash
    def to_hash
      hash = {}
      self.class.attribute_map.each_pair do |attr, param|
        value = self.send(attr)
        if value.nil?
          is_nullable = self.class.openapi_nullable.include?(attr)
          next if !is_nullable || (is_nullable && !instance_variable_defined?(:"@#{attr}"))
        end

        hash[param] = _to_hash(value)
      end
      hash
    end

  end

end
